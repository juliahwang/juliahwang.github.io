---
layout: post
title: level1. 행렬의 덧셈
categories: [알고리즘-programmers]
tags: [알고리즘, 파이썬]
description: 
---

>행렬의 덧셈은 행과 열의 크기가 같은 두 행렬의 같은 행, 같은 열의 값을 서로 더한 결과가 됩니다. 
2개의 행렬을 입력받는 sumMatrix 함수를 완성하여 
행렬 덧셈의 결과를 반환해 주세요.

> 예를 들어 2x2 행렬인 
A = ((1, 2), (2, 3)), 
B = ((3, 4), (5, 6)) 가 주어지면, 
같은 2x2 행렬인
((4, 6), (7, 9))를 반환하면 됩니다.
(어떠한 행렬에도 대응하는 함수를 완성해주세요.)

<a href="https://programmers.co.kr/learn/challenge_codes/148" target="_blank">문제 보러가기</a>

<br>

## 코드 및 풀이

처음에 애를 먹은 이유는 **문제의 마지막 문장을 간과했기 때문**이다. 어떠한 행렬에도 대응하는 함수를 만들어야하는데, answer의 리스트 형식을 만드는 데에서 시간을 많이 잡아먹었다. 

결국에는 for 반복문 안에서 행렬 길이만큼 내부 리스트를 더해주는 식으로 해결했다. 

이렇게 해주면 `1 * 1`, `2 * 2`, `3 * 3` 등 모든 경우의 행렬에 대응을 할 수 있는 `answer` 리스트가 생성된다. 

```python
def sumMatrix(A,B):
    answer = []
    for i in range(len(A)):
        answer.append([])
        for j in range(len(A[0])):
            answer[i].append(A[i][j] + B[i][j])
    return answer
    
print("1",sumMatrix([[1]], [[3]]))
print("2",sumMatrix([[1,2]], [[3,4]]))
print("3", sumMatrix([[1,2,3], [2,3,4]], [[3,4,5],[5,6,7]]))
print("4", sumMatrix([[1,2,3,4], [3,4,5,6]], [[1,2,3,4], [3,4,5,6]]))
print("5", sumMatrix([[1,2,3,4,5,6,7,8,9,10,11], [2,3,4,5,6,7,8,9,10,11,12]], [[3,4,5,6,7,8,9,10,11,12,13],[5,6,7,8,9,10,11,12,13,14,15]]))
print("6", sumMatrix([[1,2,3,4,5,6,7,8,9], [2,3,4,5,6,7,8,9,10]], [[3,4,5,6,7,8,9,10,11],[5,6,7,8,9,10,11,12,13]]))

# 1 [[4]]
# 2 [[4, 6]]
# 3 [[4, 6, 8], [7, 9, 11]]
# 4 [[2, 4, 6, 8], [6, 8, 10, 12]]
# 5 [[4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24], [7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27]]
# 6 [[4, 6, 8, 10, 12, 14, 16, 18, 20], [7, 9, 11, 13, 15, 17, 19, 21, 23]]
```

<br>


다른 사람의 코드를 참고하면 다음과 같다. 두 번째 방식은 `zip()` 내장함수를 사용했는데, `zip()`은 동일한 개수와 자료형을 갖는 리스트들의 공통 인덱스 값끼리 새로운 리스트로 묶어준다. 

```python
# 타인의 코드 - zip() 사용

def sumMatrix_2(A,B):
    answer = [[c + d for c, d in zip(a, b)] for a, b in zip(A, B)]
    return answer

print(sumMatrix([[1,2], [2,3]], [[3,4], [5,6]]))
# [[4, 6], [7, 9]]
```

<br>

3번째는 `answer`라는 새로운 리스트를 만들지 않고 인자로 준 리스트를 활용하여 결과값을 리턴한다. (왜 이 방식을 생각하지 못했을까? 하는 생각이 들어 요약해보았다.)

```python
def sumMatrix_3(A, B):
    for i in range(len(A)):
        for j in range(len(A[0])):
            A[i][j] += B[i][j]
    return A
    
print(sumMatrix([[1,2], [2,3]], [[3,4], [5,6]]))
# [[4, 6], [7, 9]]
```

<br>

4번째는 `numpy`를 사용한 방식이다. import를 해와야한다는 것이 꺼림칙하지만 배열을 사용하여 쉽게 연산한 후 `tolist()`를 사용하여 리스트 형태로 변환해주었다. 

```python
# numpy 이용하기

import numpy as np

def sumMatrix_4(A, B):
    A = np.array(A)
    B = np.array(B)
    answer = A + B
    
    print(type(answer))
    # <class 'numpy.ndarray'>
    
    return answer.tolist()
    
print(sumMatrix([[1,2], [2,3]], [[3,4], [5,6]]))
# [[4, 6], [7, 9]]
```

<br>

5번째는 시도를 했으나 리스트 범위를 제대로 생각하지 못해서 사용할 수 없었던 리스트 컴프리핸션을 사용한 방식이다. 

```python
# 타인의 코드 - list comprehension 사용하기

def sumMatrix_5(A, B):
    # A의 행렬 갯수만큼 연산을 반복하는데, 내부에서는 A[0]의 갯수만큼 값들을 하나씩 더한 후 하나의 리스트로 반환한다. 
    answer = [[A[i][j] + B[i][j] for j in range(len(A[0]))] for i in range(len(A))]
    
    return answer
    
print(sumMatrix([[1,2], [2,3]], [[3,4], [5,6]]))
```

<br>

## 풀이 별 실행시간 측정하기 

각각의 함수를 100,000번 반복한 실행시간의 평균을 구했을 때 다음과 같이 시간이 걸린다. `numpy`로 풀이할 때의 실행 시간이 가장 짧았다. 

```python
print(avg_time(e.sumMatrix_1([[1,2,3,4,5,6,7,8,9], [2,3,4,5,6,7,8,9,10]], [[3,4,5,6,7,8,9,10,11],[5,6,7,8,9,10,11,12,13]])))
# 0.6800000846851617

print(avg_time(e.sumMatrix_2([[1,2,3,4,5,6,7,8,9], [2,3,4,5,6,7,8,9,10]], [[3,4,5,6,7,8,9,10,11],[5,6,7,8,9,10,11,12,13]])))
# 0.5690017133019865

print(avg_time(e.sumMatrix_3([[1,2,3,4,5,6,7,8,9], [2,3,4,5,6,7,8,9,10]], [[3,4,5,6,7,8,9,10,11],[5,6,7,8,9,10,11,12,13]])))
# 0.6039990694262087

print(avg_time(e.sumMatrix_4([[1,2,3,4,5,6,7,8,9], [2,3,4,5,6,7,8,9,10]], [[3,4,5,6,7,8,9,10,11],[5,6,7,8,9,10,11,12,13]])))
# 0.6640002538915724

print(avg_time(e.sumMatrix_5([[1,2,3,4,5,6,7,8,9], [2,3,4,5,6,7,8,9,10]], [[3,4,5,6,7,8,9,10,11],[5,6,7,8,9,10,11,12,13]])))
# 0.6330010364763439
```

<br>
